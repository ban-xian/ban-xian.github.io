---
title: 项目常用的 JavaScript 代码片段
date: 2024-06-19 15:55:40
permalink: /pages/basic/
editLink: false
categories:
  - 前端
  - JavaScript
tags:
  - JavaScript
---

# 项目常用的 JavaScript 代码片段

### 1. 下载一个 excel 文档

同时适用于 word,ppt 等浏览器不会默认执行预览的文档,也可以用于下载后端接口返回的流数据。

```js
//下载一个链接
const download = (link, name) => {
  //如果没有提供名字，从给的Link中截取最后一坨
  if (!name) name = link.slice(link.lastIndexOf('/') + 1)
  let eleLink = document.createElement('a')
  eleLink.download = name
  eleLink.style.display = 'none'
  eleLink.href = link
  document.body.appendChild(eleLink)
  eleLink.click()
  document.body.removeChild(eleLink)
}
```

使用方式

```js
download('http://111.229.14.189/file/1.xlsx')
download('http://111.229.14.189/gk-api/util/download?file=1.jpg')
download('http://111.229.14.189/gk-api/util/download?file=1.mp4')
```

### 2. 在浏览器中自定义下载一些内容

场景：下载一些 DOM 内容，下载一个 JSON 文件

```js
/**
 * 浏览器下载静态文件
 * @param {String} name 文件名
 * @param {String} content 文件内容
 */
const downloadFile = (name, content) => {
  if (typeof name == 'undefined') throw new Error('The first parameter name is a must')
  if (typeof content == 'undefined') throw new Error('The second parameter content is a must')
  if (!(content instanceof Blob)) content = new Blob([content])
  const link = URL.createObjectURL(content)
  // 调用方法1
  download(link, name)
}
```

使用方式

```js
downloadFile('1.txt', 'lalalallalalla')
downloadFile('1.json', JSON.stringify({ name: 'hahahha' }))
```

### 3. 提供一个图片链接，点击下载

图片、pdf 等文件，浏览器会默认执行预览，不能调用 download 方法进行下载，需要先把图片、pdf 等文件转成 blob，再调用 download 方法进行下载，转换的方式是使用 axios 请求对应的链接。

```js
//可以用来下载浏览器会默认预览的文件类型，例如mp4,jpg等
import axios from 'axios'
//提供一个link，完成文件下载
const downloadByLink = (link, fileName) => {
  axios
    .request({
      url: link,
      responseType: 'blob', //关键代码，让axios把响应改成blob
    })
    .then((res) => {
      const link = URL.createObjectURL(res.data)
      // 调用方法1
      download(link, fileName)
    })
}
```

使用方式

```js
downloadByLink('http://xxx.com/xxx.ppt')
```

### 4. 防抖

在一定时间间隔内，多次调用一个方法，只会执行一次。
这个方法的实现是从 Lodash 库中 copy 的。

```js
/**
 *
 * @param {*} func 要进行debouce的函数
 * @param {*} wait 等待时间,默认500ms
 * @param {*} immediate 是否立即执行
 */
const debounce = (func, wait = 500, immediate = false) => {
  let timeout
  return function () {
    let context = this
    let args = arguments
    if (timeout) clearTimeout(timeout)
    if (immediate) {
      // 如果已经执行过，不再执行
      let callNow = !timeout
      timeout = setTimeout(function () {
        timeout = null
      }, wait)
      if (callNow) func.apply(context, args)
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args)
      }, wait)
    }
  }
}
```

使用方式

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input id="input" />
    <script>
      function onInput() {
        console.log('1111')
      }
      const debounceOnInput = debounce(onInput)
      // 在Input中输入，多次调用只会在调用结束之后，等待500ms触发一次
      document.getElementById('input').addEventListener('input', debounceOnInput)
    </script>
  </body>
</html>
```

如果第三个参数<code style="margin: 3px;padding: 3px;outline: 0px;font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);">immediate</code>传 true，则会立即执行一次调用，后续的调用不会在执行，可以自己在代码中试一下

### 5. 节流

多次调用方法，按照一定的时间间隔执行。
这个方法的实现也是从 Lodash 库中 copy 的。

```js
/**
 * 节流，多次触发，间隔时间段执行
 * @param {Function} func
 * @param {Int} wait
 * @param {Object} options
 */
const throttle = (func, wait = 500, options) => {
  let timeout, context, args
  let previous = 0
  if (!options) options = { leading: false, trailing: true }
  let later = function () {
    previous = options.leading === false ? 0 : new Date().getTime()
    timeout = null
    func.apply(context, args)
    if (!timeout) context = args = null
  }
  const throttled = function () {
    let now = new Date().getTime()
    if (!previous && options.leading === false) previous = now
    let remaining = wait - (now - previous)
    context = this
    args = arguments
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout)
        timeout = null
      }
      previous = now
      func.apply(context, args)
      if (!timeout) context = args = null
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining)
    }
  }
  return throttled
}
```

第三个参数还有点复杂，<code style="margin: 3px;padding: 3px;outline: 0px;font-size: 14px;border-radius: 4px;font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(155, 110, 35);background-color: rgb(255, 245, 227);">options</code>

<ul>
  <li>leading，函数在每个等待时延的开始被调用，默认值为false</li>
  <li>trailing，函数在每个等待时延的结束被调用，默认值是true</li>
</ul>
可以根据不同的值来设置不同的效果：
<ul>
  <li>leading-false，trailing-true：默认情况，即在延时结束后才会调用函数</li>
  <li>leading-true，trailing-true：在延时开始时就调用，延时结束后也会调用</li>
  <li>leading-true, trailing-false：只在延时开始时调用</li>
</ul>
使用方式

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input id="input" />
    <script>
      function onInput() {
        console.log('1111')
      }
      const throttleOnInput = throttle(onInput)
      // 在Input中输入，每隔500ms执行一次代码
      document.getElementById('input').addEventListener('input', throttleOnInput)
    </script>
  </body>
</html>
```

### 6. cleanObject

去除对象中 value 为空(null,undefined,'')的属性
使用场景是：接口传参某个字段为空剔除不传。

```js
const cleanObject = (object) => {
  if (!object) return {}
  let result = {}
  Object.keys(object).forEach((key) => {
    const value = object[key]
    if (value) result = { ...result, [key]: value }
  })
  return result
}
```

使用方式

```js
const newObj = cleanObject({
  name: '',
  pageSize: 10,
  page: 1,
})
console.log('res', res) // 输出{ page: 1, pageSize: 10 }
```

### 7. 获取文件后缀名

使用场景：上传文件判断后缀名

```js
/**
 * 获取文件后缀名
 * @param {String} fileName
 */
const getExt = (fileName) => {
  if (typeof fileName == 'string') return fileName.split('.').pop().toLowerCase()
  throw new Error('fileName must be a string type')
}
```

使用方式

```js
getExt('1.mp4') // -> mp4
```

### 8. 复制内容到剪贴板

```js
/**
 *原理：
 *创建一个textare元素并调用select()方法选中
 *document.execCommand('copy')方法，拷贝当前选中内容到剪贴板。
 */
const copyToBoard = (value) => {
  const element = document.createElement('textarea')
  document.body.appendChild(element)
  element.value = value
  element.select()
  if (document.execCommand('copy')) {
    document.execCommand('copy')
    document.body.removeChild(element)
    return true
  }
  document.body.removeChild(element)
  return false
}
```

使用方式

```js
// 如果复制成功返回true
copyToBoard('lalallala')
```

### 9. 休眠多少毫秒

```js
/**
 * 休眠xxxms
 * @param {Number} milliseconds
 */
const sleep = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms))
}
```

使用方式

```js
const fetchData = async () => {
  await sleep(1000)
}
```

### 10. 生成随机字符串

使用场景：用于前端生成随机的 ID,毕竟现在的 Vue 和 React 都需要绑定 key

```js
/**
 * 生成随机id
 * @param {*} length
 * @param {*} chars
 */
const uuid = (length = 8, chars) => {
  chars = chars || '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
  let result = ''
  for (let i = length; i > 0; --i) result += chars[Math.floor(Math.random() * chars.length)]
  return result
}
```

使用方式

```js
// 第一个参数指定位数，第二个字符串指定字符，都是可选参数，如果都不传，默认生成8位
uuid()
```

### 11. 简单的深拷贝

缺陷：只拷贝对象、数组以及对象数组，对于大部分场景已经足够

```js
/**
 *深拷贝
 * @param {*} obj
 * @returns
 */
const deepCopy = (obj) => {
  if (typeof obj != 'object') return obj
  if (obj == null) return obj
  return JSON.parse(JSON.stringify(obj))
}
```

使用方式

```js
const person = { name: 'xiaoming', child: { name: 'Jack' } }
deepCopy(person)
```

### 12. 数组去重

原理：利用 Set 中不能出现重复元素的特性

```js
/**
 * 数组去重
 * @param {*} arr
 */
const uniqueArray = (arr) => {
  if (!Array.isArray(arr)) throw new Error('The first parameter must be an array')
  if (arr.length == 1) return arr
  return [...new Set(arr)]
}
```

使用方式

```js
uniqueArray([1, 1, 1, 1, 1]) // [1]
```

### 13. 对象转化为 FormData 对象

使用场景：上传文件时我们要新建一个 FormData 对象，然后有多少个参数就 append 多少次，使用该函数可以简化逻辑

```js
/**
 * 对象转化为formdata
 * @param {Object} object
 */

const getFormData = (object) => {
  const formData = new FormData()
  Object.keys(object).forEach((key) => {
    const value = object[key]
    if (Array.isArray(value)) {
      value.forEach((subValue, i) => formData.append(key + `[${i}]`, subValue))
    } else {
      formData.append(key, object[key])
    }
  })
  return formData
}
```

使用方式

```js
const req = {
  file: 'xxx',
  userId: 1,
  phone: '15198763636',
}
getFormData(req)
```

### 14. 保留到小数点以后 n 位

使用场景：JS 的浮点数超长，有时候页面显示时需要保留 2 位小数

```js
const cutNumber = (number, no = 2) => {
  if (typeof number != 'number') number = Number(number)
  return Number(number.toFixed(no))
}
```

使用方式

```js
cutNumber(3.1415926)
```

### 15. 获取基础 URL

```js
const getBaseURL = (url) => url.replace(/[?#].*$/, '')
```

使用方式

```js
getBaseURL('http://url.com/page?name=Adam&surname=Smith') // 'http://url.com/page'
```

### 16. 判断网址是否为绝对网址

```js
const isAbsoluteURL = (str) => /^[a-z][a-z0-9+.-]*:/.test(str)
```

使用方式

```js
isAbsoluteURL('https://google.com') // true
isAbsoluteURL('ftp://www.myserver.net') // true
isAbsoluteURL('/foo/bar') // false
```

### 17. 获取 URL 参数作为对象

```js
const getURLParameters = (url) =>
  (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(
    (a, v) => ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a),
    {},
  )
```

使用方式

```js
getURLParameters('google.com') // {}
getURLParameters('http://url.com/page?name=Adam&surname=Smith') // {name: 'Adam', surname: 'Smith'}
```

### 18. 检查元素是否包含另一个元素

```js
const elementContains = (parent, child) => parent !== child && parent.contains(child)
```

使用方式

```js
elementContains(document.querySelector('head'), document.querySelector('title')) // true
elementContains(document.querySelector('body'), document.querySelector('body')) // false
```

### 19. 获取元素的所有祖先

```js
const getAncestors = (el) => {
  let ancestors = []
  while (el) {
    ancestors.unshift(el)
    el = el.parentNode
  }
  return ancestors
}
```

使用方式

```js
getAncestors(document.querySelector('nav')) // [document, html, body, header, nav]
```

### 20. 平滑滚动元素进入视图

```js
const smoothScroll = (element) =>
  document.querySelector(element).scrollIntoView({
    behavior: 'smooth',
  })
```

使用方式

```js
smoothScroll('#fooBar')
smoothScroll('.fooBar')
```

### 21. 处理元素外的点击

```js
const onClickOutside = (element, callback) => {
  document.addEventListener('click', (e) => {
    if (!element.contains(e.target)) callback()
  })
}
```

使用方式

```js
onClickOutside('#my-element', () => console.log('Hello'))
```

### 22. 生成 UUID

```js
const UUIDGeneratorBrowser = () =>
  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
    (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16),
  )
```

使用方式

```js
UUIDGeneratorBrowser() // '0568875f-6106-4621-9bab-6be33b410027'
```

### 23. 获取选中的文本

```js
const getSelectedText = () => window.getSelection().toString()
```

使用方式

```js
getSelectedText()
```

### 24. 给 HTML 元素添加样式

```js
const addStyles = (el, styles) => Object.assign(el.style, styles)
```

使用方式

```js
addStyles(document.getElementById('my-element'), {
  background: 'red',
  color: '#ffff00',
  fontSize: '3rem',
})
```

### 25. 切换全屏模式

```js
const fullscreen = (mode = true, el = 'body') =>
  mode ? document.querySelector(el).requestFullscreen() : document.exitFullscreen()
```

使用方式

```js
fullscreen()
fullscreen(false)
```

### 26. 检测 Caps Lock 是否开启

```html
<form>
  <label for="username">Username:</label>
  <input id="username" name="username" />
  <label for="password">Password:</label>
  <input id="password" name="password" type="password" />
  <span id="password-message" style="display: none">大写锁定已开启</span>
</form>
<script>
  const el = document.getElementById('password')
  const msg = document.getElementById('password-message')
  el.addEventListener('keyup', (e) => {
    msg.style = e.getModifierState('CapsLock') ? 'display: block' : 'display: none'
  })
</script>
```

### 27. 看日期是否有效

```js
const isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf())
```

使用方式

```js
isDateValid('December 17, 1995 03:24:00') // true
isDateValid('1995-12-17T03:24:00') // true
isDateValid('1995-12-17 T03:24:00') // false
isDateValid('Duck') // false
isDateValid(1995, 11, 17) // true
isDateValid(1995, 11, 17, 'Duck') // false
isDateValid({}) // false
```

### 28. 从 Date 中获取冒号时间

```js
const getColonTimeFromDate = (date) => date.toTimeString().slice(0, 8)
```

使用方式

```js
getColonTimeFromDate(new Date()) // '09:39:08'
```

### 29. 从 Date 生成 UNIX 时间戳

```js
const getTimestamp = (date = new Date()) => Math.floor(date.getTime() / 1000)
```

使用方式

```js
getTimestamp() // 1720057242
```

### 30. 查看当前用户的首选语言

```js
const detectLanguage = (defaultLang = 'en-US') =>
  navigator.language ||
  (Array.isArray(navigator.languages) && navigator.languages[0]) ||
  defaultLang
```

使用方式

```js
detectLanguage() // 'zh-CN'
```

### 31. 查看用户偏好的配色方案

```js
const prefersDarkColorScheme = () =>
  window && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
```

使用方式

```js
prefersDarkColorScheme() // false
```

### 32. 查看设备是否支持触摸事件

```js
const supportsTouchEvents = () => window && 'ontouchstart' in window
```

使用方式

```js
supportsTouchEvents() // true
```
